<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
    <head>

        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
        <title>- Modeling Technique</title>
        <link rel="shortcut icon" type="image/png" href="../common/images/mcln-logo.png">

        <meta name="author" content="Vlad Lakin"/>
        <meta name="version" content="last updated 08/17/2018"/>
        <meta name="keywords" content="dining philosophers, discrete, event, dynamical, system, simulation, simulating,
                logic, behavior, based, robotics, control, software, asynchronous, concurrent, architecture, modeling, automaton,
                Petri, Net"/>
        <meta name="news_keywords" content="Discrete Symbolic Dynamical Systems & Models,
                dining philosophers, dynamical system, behaviour based robotics"/>
        <meta name="description" content="Discrete Symbolic Dynamical Systems & Models"/>

        <!-- style sheets   -->
        <link rel="stylesheet" href="../common/stylesheets/common.css">
        <link rel="stylesheet" href="../common/stylesheets/all-pages-popups.css">

        <!--/*   S c r i p t s   */-->
        <script type="text/javascript" src="../common/javascripts/common-javascripts.js"></script>
        <script type="text/javascript" src="../common/javascripts/jquery-3.7.1.min.js"></script>
        <script type="text/javascript" src="../common/javascripts/all-pages-popup-scripts.js"></script>

        <!--/*   S t y l e    S h e e t s   */-->

        <style>
            body {
                background-image: url("../common/images/line-bg.png");
<!--                font-family: Arial, sans-serif;-->
            }

            span.column {
                flex-direction: column;
                display: inline-flex;
                flex-direction: column;
                justify-content: center;
                text-align: left;
                vertical-align: text-top;
            }

            sup {
                line-height: .5;
                font-size: 0.8em;
            }

            sub {
                line-height:  .99;
                font-size: 0.8em;
            }

            table, th, td {
                border: 1px solid black;
                border-collapse: collapse;
            }
            table {
                margin: auto;
            }
            th, td {
                font-size:12pt;
                text-align: center;
            }

        </style>
    </head>

<!--
CheckIfDiff
CheckIfSame
Equivalence
Conjunction
Production
Disjunction
Application
-->

<!-- background-image: linear-gradient(to right, rgba(255, 255, 255, 0), #ffffff 50%);-->

<!--    }-   CC28E8; -->
<!--            color: #35664D;  #695EA6 7064B1;-->
<!--    3366CC - Blue        color: #551ABB; purple - #205081; color: #888888;  -->

    <body onload="removeHashTag()">
<!--    <body onload="initMMTPage(); removeHashTag()">-->
    <div class="container"> <!-- Main Container -->
        <img  style="height: 6px; width: 100%;" src="../common/images/two-red-lines.png" alt=""/>

        <a href="../kp-qds/kp-qds.html">
            <img src="../common/images/prev.png" alt="Previous Page"></a>

        <a style="margin-left: 7pt;margin-right: 7pt;"  href="../index.html#sec.2.0">
            <img src="../common/images/up.png" alt="Main Page"></a>

        <a href="../kp-aos/kp-aos.html">
            <img src="../common/images/next.png" alt="Next Page"></a>

        <!-- =================================================================================== -->

        <!--    H e a d e r  font: 14px Ariel, Helvetica; -->

        <!-- THIS TEXT IS COPIED on 2024.12.17 FROM FILE: "Z 24.12.10 MMT A-C-C TRANSLATED"  last touched on 2024.12.14 -->

        <div class="text-container">

        <div class="page-header">
            Qualitative Dynamical Systems Mathematical Modeling Technique
        </div>

            <div style="margin-top: 33px; margin-bottom: 0px; "> <!-- content holder -->

                <p>
                    While studying behavior of dynamical systems phenomenologically - that is not by delving
                    into their internal machinery, but instead considering only abstract collections of
                    their properties, changing over time - we, following fundamental principles of
                    mathematical modeling, tend to explain causes of changes of states of the properties by
                    existence of certain dependence relations of the states of properties on changes of
                    states of the same or some other properties; and, optionally, on the effects of external
                    systems or the environment.
                </p>

                <p>
                    The objective of this page is to introduce Qualitative Dynamical Systems Mathematical Modeling
                    Technique, developed as part of the Kaleidoscope Project, and to describe modeling solutions
                    proposed by the Technique. The purpose of this technique and its solutions is to enable
                    creating qualitative systems simulation models, capable of reproducing behavior of existing or
                    being designed qualitative dynamical systems.
                </p>

                <p class="section-header">
                    Reproducing Behavior of Qualitative Systems With Help of Their Models
                </p>

                <p>
                    Reproducing, or, in the other words, simulation modeling of behavior of  dynamical
                    systems is a process of recreating, in a model, changes of states of properties
                    of the modeled system, happening over time.  Therefore, organization of the
                    process of reproducing behavior of these systems presumes creating models capable
                    of generating sequences of changes of state of variables of the models similar to
                    the sequences of changes of state of properties observed in the modeled systems.
<!--                    Reproducing or, in the other words, simulation modeling of behavior of qualitative-->
<!--                    dynamical systems is, in essence, a process of recreating, in the models, changes-->
<!--                    of states of properties of the modeled systems, happening over time. By definition-->
<!--                    of the dynamical systems, all new changes in their state are explained by the-->
<!--                    changes happened  in their state earlier. Therefore, the organization of process of-->
<!--                    reproducing their behavior presumes creation of such models which could be capable-->
<!--                    of generating the same sequences of changes of state of variables of the models as-->
<!--                    the sequences of changes of the state of properties observed in the modeled systems.-->

    <!--                Reproducing or, in the other words, simulation modeling of behavior of qualitative-->
    <!--                dynamical systems is, in essence, a process of recreating, in the models, changes-->
    <!--                of states of properties of the modeled systems, happening over time. And, since-->
    <!--                by definition of these systems, all the changes in their state are explained by-->
    <!--                the changes happened in them earlier, organization of process of reproducing their-->
    <!--                behavior presumes creation of such models which could be used for generating in them-->
    <!--                same sequences of transitions of variables of the models from their current state-->
    <!--                to the next one, as those observed in the properties of the modeled systems.-->

    <!--                To reproduce behavior of dynamical systems, or, in the other words-->
    <!--                to conduct simulation modeling of behavior of these systems, is a process of recreation-->
    <!--                of changes observed in the state of modeled systems with the help of the simulation-->
    <!--                models of these systems. And, since by definition of behavior of dynamical-->
    <!--                systems, all changes of their state are explained by the changes in the state-->
    <!--                of the systems happened earlier, organization of process of reproducing behavior-->
    <!--                of the systems presumes creating such models that could be used-->
    <!--                by the simulation process for generating the same sequences of transitions of states-->
    <!--                of models from their current state to the next one, as those observed in the modeled-->
    <!--                systems.-->
                </p>

                <p>
                    So, since, by definition of the dynamical systems, all the changes in their state
                    are explained by the changes in the state of the systems happened earlier, the
                    process of reproducing behavior of a particular <em>qualitative dynamical system</em>
                    carried out with the help of its simulation model should be performed as the sequence of
                    transformations of current state of the model into its next state. In practice,
                    this process, thus, should begin with transformation of the initial state of the
                    model, performed at the initial moment of simulation t&nbsp;=&nbsp;0, into its state observed
                    at the next moment in time, that can be denoted as t&nbsp;=&nbsp;1. Then the state at the time
                    t&nbsp;=&nbsp;1 should be transformed into the next state observed at the next moment
                    t&nbsp;=&nbsp;2. And then the process should continue as a systematic repetition of steps of
                    transformations at the moments t&nbsp;=&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;etc., as long as this makes practical sense.
                </p>

                <p>
                    Suggested description creates understanding of role of models in the technique of
                    simulation modeling of behavior of qualitative systems. But it says nothing about
                    how the models of the systems of this kind should be defined and how they should
                    perform transformations of current states of the models into their next states.
                    Meanwhile, qualitative dynamical systems are the instances of the class of dynamical
                    systems whose changes of states are determined by the dependence relations of states
                    of properties of the systems on the combinations of states of groups of properties
                    characterizing situations. Therefore, it is assumed that:
                </p>

                <p>
                    (1) in accordance with the general technique of modeling dynamical systems any particular
                    model of a qualitative system should be defined as a collection of n variables x<sub>i</sub>,
                    where index i of variable x runs from 0 to n-1; variables should represent
                    qualitative properties of the modeled system; and values of the variables should be
                    taken from a mathematical set, characteristics of elements of which make it possible
                    to use them for representing states of qualitative properties; and that respectively:
                </p>

                <p>
                    (2) mechanism of computation of the states of the variables of the model has to be
                    defined as the system of n equations, written as: x<sub>i</sub><sup>t+1</sup> =
                    <b>f</b>(args<sup>t</sup>), where: x<sub>i</sub><sup>t+1</sup> is the state of the
                    variable x<sub>i</sub> at the time t+1; args<sup>t</sup> stands for the list of
                    arguments of the function <b>f</b>, holding values of groups of variables of the
                    model at time t; and <b>f</b> is the function computing value of variable
                    x<sub>i</sub><sup>t+1</sup>, as the dependent element of the dependence relation
                    corresponding to values of independent variables of the relation, passed to
                    the function as its arguments.
                </p>

                <p>
                    Presented on this page, modeling technique has been developed as a complex of modeling
                    solutions enabling creation of qualitative system models in the form of a system of
                    algebraic equations. Those solutions are based on the general principles of mathematical
                    modeling of dynamical systems, mentioned above, on the one hand; but also reflect
                    discrete nature of qualitative properties and the character of behavior of qualitative
                    systems, described on the page:
                    <span class="popup-link" onmouseenter="openPopup(event, popup01)"
                          onmouseleave= "closePopup(popup01)">
                        <a class="popup-link" href = "../kp-qds/kp-qds.html" target="_blank">
                            <em>"Qualitative Dynamical Systems, Their Behavior, and Mathematical Modeling",</em>
                        </a>
                    </span> on the other hand.
                </p>

                <p>
                    Following sections describe all modeling solutions, constituting the Modeling Technique, as
                    well as examples illustrating application of the solutions for writing
                    state equations of the variables in the form of algebraic equations.
                </p>

<!--                Begin. Following paragraphs are commented out as they were rewritten on 2025.06.06

                <p>
                    Suggested description creates understanding of role of a model in the technique of
                    simulation modeling of behavior of qualitative systems. But it says nothing about how
                    the models of the systems of these kind should be defined and how they should perform
                    transformations of current states of the models into their next states. Meanwhile,
                    qualitative dynamical systems are the instances of the class of dynamical systems whose
                    changes of states are determined by the dependence relations of states of properties of
                    the systems on the combinations of states of groups of properties characterizing situations.
                    Therefore, any particular model of a qualitative system should:
                </p>

                <p>
                    (1) be defined as a collection of n variables, referred to as x<sub>i</sub>, where
                    index i of variable x runs from 0 to n-1; variables represent qualitative properties of the modeled system;
                    and values of the variables are taken from a mathematical set, characteristics of elements
                    of which make it possible to use them for representing states of qualitative properties;
                    while
                </p>

                <p>
                    (2) the mechanism of computation of the states of the variables of the model has to
                    be defined as the system of n equations, written as: x<sub>i</sub><sup>t+1</sup> =
                    <b>f</b>(args<sup>t</sup>), where: x<sub>i</sub><sup>t+1</sup> is the state of the
                    variable x<sub>i</sub> at the time t+1; args<sup>t</sup> stands for the list of
                    arguments of the function <b>f</b>, holding values of groups of variables of the
                    model at time t; and <b>f</b> is the function computing value of variable
                    x<sub>i</sub><sup>t+1</sup>, as the dependent element of the dependence relation
                    corresponding to values of independent variables of the relation, passed to
                    the function as its arguments.
                </p>

                <p>
                    So, the modeling technique, intended to enable creation of simulation models of qualitative systems,
                    has been developed as a complex of modeling solutions. Those solution are
                    based on the general principles of mathematical modeling of dynamical systems, on the
                    one hand, and reflect discrete nature of qualitative properties, and the
                    character of behavior of qualitative systems, on the other hand. These solutions are described
                    in the sections listed below:
                </p>

                <p>
                    (a) domain set, elements of which can be used for representing qualitative
                    values of variables of models;
                </p>

                <p>
                    (b) qualitative model behavior specification describing all
                    changes in the state of each variable occurring in the response to all situations
                    causing that changes;
                </p>

                <p>
                    (c) state functions of variables of models of qualitative systems,
                    implemented in the form of algebraic equations;

                </p>

                <p>
                    (d) models of qualitative systems in the form of system of algebraic equations; and
                </p>

                <p>
                    (e) carrier set of model and five algebraic operations that can be used for computing algebraic
                    expressions written as the composition of these operations.
                </p>

                <p>
                    All listed, and other, associated with them, solutions, as well as an example of
                    qualitative system model, defined based on the specification of model of a concrete
                    qualitative system, are described in the following sections of this page.
                </p>

                End. Following paragraphs are commented out as they were rewritten on 2025.06.06
                -->

                <!-- ############################################################################################### -->
                <!-- D O M A I N   S E T   O F   M A T H   M O D E L S   O F   Q U A L I T A T I V E   S Y S T E M S -->
                <!-- ############################################################################################### -->

                    <p class="section-header">
                        Domain Set of Mathematical Models of<br>Qualitative Systems
                    </p>

                <p>
                    Creation of mathematical models of dynamical systems in the form of
                    collections of variables assumes having mathematical sets, nature of elements of which
                    makes it possible to use them as the values of variables, denoting  states
                    of properties of the modeled systems. Thus, for example, technique of creating models
                    of <em>quantitative systems</em>, utilizes sets of integer, real or complex numbers,
                    elements of which are used to denote magnitude of modeled properties.
                    On the other hand, techniques of modeling either logical or discrete systems,
                    propositions of which may take only two states, use sets consisting of only
                    two elements, such as "yes" and "no", or "1" and "0", depending on the
                    adopted interpretation.
                </p>

                <p>
                    In contrast, the <em>qualitative systems</em> are neither quantitative nor logical.
                    By assigning to properties of these systems different qualitative assessments of
                    their states, we assume that properties are multivalued and may take different
                    qualitative states at different times. And, thus, the elements
                    of the set which should be used as values of variables, representing qualitative states of
                    properties, will serve as unique markers of different qualities of the properties.
                    Respectively, the markers are not supposed to have any associated connotations and
                    interpretations. And, hence, the only relation that can be defined on
                    such a set should be the equivalence relation of each element of the set to itself, and its
                    non-equivalence relation with all other elements of the set.
                </p>

                <p>
                    Such a set can certainly be a set of signs. These signs can be
                    either the letters of the alphabet of a language, used for description of the model in the
                    form of text, or the codes of different colors, used
                    when the model and the states of its variables are depicted graphically.
                </p>

                <p>
                    So, the definition of the set of signs, used on this page, is the following:
                </p>

                <div class="definition-border">
                    <div class="definition-inner-border" style="padding: 0px 15px 0px 15px;">
                        <p>
                            The Mathematical Set of the models of qualitative systems is the collection
                            of uninterpreted uppercase letters of Latin alphabet, and, thus, is defined as:
                            <b>D</b> = {A, B, C, ..., Z}. Being a collection of elements which are used
                            for representing values of arguments of function and values of variables computed
                            by the functions, set <b>D</b> serves in the models as the domain and
                            the range of the state functions of variables of the models.
                        </p>
                    </div> <!-- End of definition inner border -->
                </div> <!-- End of definition outer border -->

                <p>
                    <em>Remark 1</em>. Definition of set of models in the form of the set of colors,
                    which in the context of creating qualitative systems graphical models is called a
                    Palette, is given on the page
                    <span class="popup-link" onmouseenter="openPopup(event, popup02)"
                                             onmouseleave= "closePopup(popup02)">
                        <a class="popup-link" href = "../kp-mcln/kp-mcln.html" target="_blank">
                    <em>"Multicolored Logical Net Modeling Formalism"</em>.</a></span>
                </p>

                <p>
                    <em>Remark 2</em>. Technique of description of process of computation of
                    next state of variables of the models in the form of mathematical expressions
                    written as a composition of algebraic operations, that requires having a carrier
                    set allowing definition on it operations necessary for computing algebraic expressions,
                    is described later in the sections of this page, devoted defining content of the state functions
                    of variables of the models.
                </p>

                <!-- ########################################################################################### -->
                <!--       Q U A L I T A T I V E   M O D E L   B E H A V I O R   S P E C I F I C A T I O N       -->
                <!-- ########################################################################################### -->

                <span id="MMT.SEC.1.0"></span>
                <p class="section-header">
                    Qualitative Model Behavior Specification
                </p>

                <p>
                    Whatever the modeled qualitative system may be - whether existing in  reality, or
                    (when is designed) present only in our imagination, creating its model, assumes
                    having detailed specification of dependence of states of each variable of the model
                    on the states of various groups of variables characterizing situations that can arise
                    in the model. And since such models are created for reproducing behavior of the modeled
                    systems, the structure and the content of the specification of the model has to be
                    based on observed, or assumed, dependence of states of each property of the system
                    on the occurrence of situations in the system. This dependence is described on the
                    previous page "Qualitative Dynamical Systems, Their Behavior and Mathematical Modeling",
                    in the section:
                    <span class="popup-link" onmouseenter="openPopup(event, popup03)"
                                             onmouseleave="closePopup(popup03)">
                        <a class="popup-link" href = "../kp-qds/kp-qds.html#QDS.SEC.1.0" target="_blank">
                            <em>Qualitative System Behavior Specification</em>
                        </a>
                    </span>.
                </p>

                <p>
                    Described in this section Qualitative Model Behavior Specification (QMBSpec)
                    follows the structure of the QSBSpec, in the sense that it is also defined as a list of the
                    sub-specifications. However, in this case, those
                    sub-specifications are not specs of dependence of individual
                    properties, but the ones of dependence of individual variables. Meanwhile, unlike the QSBSpec (each element of which
                    describes a single Correspondence of proposed state of property to expected
                    situation) -  each element of the QMBSpec is defined as the pair: [name of the
                    variable / list of all Correspondences]. In this structure the Correspondences determine
                    dependence of all states of the variable of the pair on all expected situations.
                </p>

                <p>
                    Thus, in order to describe content of the QMBSpec, elements of its list  are
                    named: State Variable Dependence Specification (SVDSpec). Variables in each
                    SVDSpecs are named x<sub>i</sub>, and values of the variables are denoted by constants
                    taken from the set <b>D</b>. General form of structure of the QMBSpec is presented in Figure 1.
                </p>
<!--                <p>-->
<!--                    General form of structure of the QMBSpec is presented in Figure 1.-->
<!--                </p>-->
                <p>
                <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QMBSpec: {<br></div>
                <div style="text-align: center;">
                    <b>L</b> <span class="column"><sup>n</sup><sub>i=0</sub></span>
                    SVDSpecs
                    { x<sub>i</sub> : <b>C</b> <span class="column"><sup>cn(i)</sup><sub>j=0</sub></span>
                    { cv<span class="column"><sup>t+1</sup><sub>i,j</sub></span> :
                    <b>S</b> <span class="column"><sup>sn(i,j)</sup><sub>k=0</sub></span>
                    { x<sub>i,j,k</sub>
                    : ev<span class="column"><sup>t</sup><sub>i,j,k</sub></span>  } } }
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};

                <p style = "text-align: center;">
                    <b>Figure 1.</b> Structure of Qualitative Model Behavior Specification.
                </p>

                <p>
                    In this Figure:
                </p>

                <p>
                    (1) QMBSpec is defined as the iterator through the list <b>L</b>
                    <span class="column"><sup>n</sup><sub>i=0</sub></span> of n SVDSpec<sub>i</sub>.
                </p>

                <p>
                    (2) Each i-th SVDSpec<sub>i</sub> { x<sub>i</sub>   :
                    <b>C</b> <span class="column"><sup>cn(i)</sup><sub>j=0</sub></span>
                    { } } is a pair, where the first element
                    of the pair x<sub>i</sub> is the dependent variable of the SVDSpec<sub>i</sub>, whereas the second
                    is the iterator through the list of Correspondences <b>C</b>
                    <span class="column"><sup>cn(i)</sup><sub>j=0</sub></span>, number of which cn(i) depends on
                    index i.
                </p>
<!--                of i,j-th Correspondences.-->
                <p>
                    (3) Each i,j-th Correspondence { cv<span class="column"><sup>t+1</sup><sub>i,j</sub></span> :
                    <b>S</b> <span class="column"><sup>sn(i,j)</sup><sub>k=0</sub></span> {  } is also a pair.
                    In that pair first element cv<span class="column"><sup>t+1</sup><sub>i,j</sub></span> belongs to
                    domain set <b>D</b>. It is a constant value which is supposed to be assigned to
                    variable x<sub>i</sub> as its proposed value, in response of the model to emergence of the i,j-th
                    situation <b>S</b> <span class="column"><sup>sn(i,j)</sup><sub>k=0</sub></span>,
                    described in the second part of the pair.
                </p>

                <p>
                    (4) Each i,j-th situation <b>S</b> <span class="column"><sup>sn(i,j)</sup><sub>k=0</sub></span>
                    is also the list, and each i,j,k-th element of the list
                    is the pair described as { x<sub>i,j,k</sub>  :
                    ev<span class="column"><sup>t</sup><sub>i,j,k</sub></span> }.
                    The first element of the pair is the variable
                    x<sub>i,j,k</sub> and the second is the constant
                    ev<span class="column"><sup>t</sup><sub>i,j,k</sub></span> which
                    belongs to domain set <b>D</b>. Thus both: the variable and the constant are
                    the k-th elements of the i,j-th situation of i,j-th Correspondence of i-the variable of
                    the specification QMBSpec.
                </p>

                <p>
                    <em>To summarize</em>.
                    Conversion of the QSBSpec to the QMBSpec is accomplished by replacing unique
                    identifiers used in the QSBSpec, with the names of the variables suggested by the modeling
                    technique, and the identifiers of states of the properties with the elements of the domain
                    set <b>D</b>, chosen to represent states of properties,
                </p>

                <!-- ########################################################################################### -->
                <!--                C O M P U T A T I O N   O F   S T A T E   F U N C T I O N                    -->
                <!-- ########################################################################################### -->

                <p class="section-header">
                    State Functions of Variables of Models of Qualitative Systems
                </p>

                <p>
                    To define a function, in a general sense, means to suggest a way for computing
                    its values for all possible combinations of values of its arguments. Respectively,
                    in order to define state function of a variable of a model of qualitative
                    system (intended for reproducing changes of state of the modeled property observed
                    in a modeled system), it is necessary to define a computation procedure of
                    the function, capable of producing values of the variable for all possible
                    combinations of values of groups of variables of the model, characterizing
                    situations which are described in the Correspondences of the SVDSpec of the
                    variable being computed and which ought to be passed to the function as its arguments.
                </p>

                <p>
                    However, in order to construct such a computation procedure, it is necessary to take
                    into account that the suggested way for its computing must ensure obtaining
                    results despite the challenges caused by the characteristics of dependence
                    of states of variables of models of the qualitative systems on irregularities
                    of the occurrence of situations in those systems.
                </p>

                <p class="second-level-section-header">
                    Content of Computation Procedure of State Functions of Variables
                </p>

                <p>
                    Being, by their nature, the systems of simultaneously acting components which
                    produce asynchronous and fragmentary changes in the state of properties of
                    the systems, both the qualitative systems and their behavior are characterized
                    by the fact that, the all transformations of state of properties of the system
                    into their next state, performed at any particular moment in time, are really
                    caused by not all, but only the part of all the variety of situations that can
                    emerge and be present in a system.
                </p>

                <p>
                    This statement actually means that since concrete content of situations can
                    be formed in the model only immediately before computing each of its functions,
                    and thus that the knowledge on which of the situations, expected by the function,
                    must be passed to it as arguments and which are not, cannot be obtained until
                    its computation begins, absolutely all groups of variables listed in the
                    SVDSpec, must be included in the list of arguments of state function of each
                    variable; so to say just in case. And, thus, because of that, it turns out that, not
                    all, but only those groups of arguments, that at the moment of computation of
                    the functions,  characterize expected situations, can be used for computing
                    values of functions (and their variables) corresponding to the expected
                    situations.
                </p>

                <p>
                    Hence, taking into account all that has been said by now, in order to compute the
                    function, its procedure (that can be also referred as the algorithm) have to be enabled
                    for: a) systematic scanning all groups of arguments of the function for
                    identifying among them expected situations; b) producing either the real
                    proposed values of the variable taken from the Correspondences of
                    the Specification in cases when a single, or a few, expected situation
                    are detected in the arguments, or, alternatively, producing proposed values
                    marked with some auxiliary symbol that should be used to denote produced proposed
                    value as undefined; c) generating final proposed value of the function out of
                    all proposed values (defined or undefined), assuming that it may come out as
                    undefined in cases  when either none of the expected situations are present in
                    the model, or when two or more existing situations produce different proposed values
                    and, thus, create uncertainty in choosing a single value of the function; and, at
                    the end, d) sorting out cases when final proposed value turned out undefined and
                    leaving computed variable unchanged, when it does.
<!--                    ; and b) generate final proposed value of the function-->
<!--                    out of all proposed values, either obtained as corresponding to all existing-->
<!--                    or not existing situations by analysing their values with the intention to-->
<!--                    distinguish three possible outcomes identified as cases occurring when:-->
                </p>

<!--                <p>-->
<!--                    (1) none of the situations, described in the SVDSpec of the variable, is-->
<!--                    present in the state of the model, and, therefore, in order to avoid corruption-->
<!--                    of the state of variable, the final proposed value of the function should-->
<!--                    be marked with some auxiliary symbol indicating that this value is undefined; or when-->
<!--                </p>-->

<!--                <p>-->
<!--                    (2) there are found one or more situations proposed values of which require-->
<!--                    the variable to transition to the same state which means that any of these-->
<!--                    proposed values may be assigned to final proposed value of the function;-->
<!--                    or when-->
<!--                </p>-->

<!--                <p>-->
<!--                    (3) two or more simultaneously existing situations produce different states-->
<!--                    which has to be assigned to the computed variable at once, and thus, in order-->
<!--                    to avoid collision among the proposed state of the computed variable occurring-->
<!--                    in that case, the final proposed state of the variable should, similar to-->
<!--                    the case 1, be marked with some other auxiliary symbol, that also does not-->
<!--                    belong to the set <b>D</b>, indicating conflict of the proposed values.-->
<!--                </p>-->

<!--                <p>-->
<!--                    So,  only case 2 produces valid final proposed value and later assigns-->
<!--                    it to the computed variable, but the final proposed value produced-->
<!--                    in cases 1 and 3 are invalid. They indicate that next-->
<!--                    value of the function is undefined and therefore the current value of the-->
<!--                    variable should remain unchanged. However,  a solution, suitable to the cases-->
<!--                    1 and 3, which makes any undefined final proposed value of the function to be-->
<!--                    always defined exists. This solution suggests the function has to always-->
<!--                    produce the current value of the variable, instead of the final proposed-->
<!--                    value of the function when the computed final proposed value  is undefined.-->
<!--                    With this approach, the computed variable, that is already in its current state,-->
<!--                    gets the same current value again, and, thus, leaves the value of the variable-->
<!--                    effectively unchanged.-->
<!--                </p>-->

                <p class="second-level-section-header">
                    Proposal of Implementation of State Functions of Variables in the Form of Algebraic Expressions
                </p>

<!--            // Added on 2025.05.26-->
                <p>
                    If a model of a qualitative system were created as a computer program, then each of
                    its functions, based on the understanding of its content, described above, would most
                    likely be implemented in the form of a loop through all groups of its arguments,
                    characterizing different situations expected by the function. Whereas, each iteration
                    of the loop could begin with the test if the situation, being processed, is present
                    in the state of the model, and performing computation of the value of the function
                    by checking state of data and executing computational operations depending on whether
                    the situation is present or not.
                </p>

<!--                <p>-->
<!--                    If a model of a qualitative system were created as a computer program, then each-->
<!--                    of its functions, based on the understanding of its content described above,-->
<!--                    would most likely be implemented in the form of a loop through all groups of-->
<!--                    its arguments; some of which would represent situations expected by the-->
<!--                    function, while the others not. Whereas, each iteration of the loop could-->
<!--                    begin with the test whether the group of arguments, being processed in the-->
<!--                    current iteration, characterizes expected situation, and then performing-->
<!--                    computing the value of the function by checking state of the data and executing-->
<!--                    computational operations depending on whether the processed situation is-->
<!--                    present in the state of the model or not.-->
<!--                </p>-->

<!--            // Added on 2025.05.26-->
                <p>
                    However, when creating mathematical models of qualitative systems, whose functions should be
                    defined as algebraic expressions, we have to deal with such a kind of computation, dataflow
                    in which, so to speak, is laminar. And, thus, it can develop only in one direction - from
                    the values of independent elements of the dependence relation of the variable, i.e.,
                    from the arguments of the function (leaves of the computation tree) to the dependent
                    element of the relation, i.e., the computed value of the function (root of the
                    computation tree). And, it is obvious, that this process cannot contain any
                    cycles, and to branch out in order to execute some computational operations
                    while bypassing others depending on the state of the data.
                </p>

<!--                // Added on 2025.05.25-->
<!--                <p>-->
<!--                    But when creating mathematical models whose functions are defined as algebraic-->
<!--                    expression, we have to deal with such kind of computation, dataflow in which can-->
<!--                    develop only in one direction - from the values of independent elements of the-->
<!--                    dependence relation of the variable, i.e., from the arguments of the function-->
<!--                    (leaves of the computation tree) to the dependent element of the relation, i.e.,-->
<!--                    the computed value of the function (root of the computation tree). And, it is-->
<!--                    obvious, that this process cannot contain any cycles, and to branch out in order-->
<!--                    to execute some computational operations while bypassing others depending on the-->
<!--                    state of the data.-->
<!--                </p>-->

<!--            // Added on 2025.05.26-->
                <p>
                    Described in this section approach to computing a function in the form of an
                    algebraic expression is an experimental attempt to fit into an inherently linear
                    process of sequential execution of operations of algebraic expression, all such
                    features of algorithms as: cycles, dynamic computation of estimates of states
                    of data, and conditional choices for executing some operations while bypassing
                    others; which usually make structure of algorithm quite branchy.
                </p>

<!--            // Added on 2025.05.25-->
<!--                <p>-->
<!--                    So, making attempt to imagine how to fit into the sequential computational process,-->
<!--                    inherent in the algebraic expressions, all such features of algorithms as cycles,-->
<!--                    computations of runtime estimates of state of data and conditional execution of-->
<!--                    some operations while bypassing the others, we have nothing left, but to assume-->
<!--                    that in order to implement a function computation procedure in the form of-->
<!--                    algebraic expression one should rely on following considerations, developed as a-->
<!--                    part of model defining solutions of the modeling technique. As it was shown by-->
<!--                    the study, the possibility of implementing functions of models of qualitative-->
<!--                    systems in the form of algebraic expressions is determined by the following-->
<!--                    solutions.-->
<!--                </p>-->

                <p class="third-level-section-header-bold-line-size">
                    From Computer Algorithm to Algebraic Sequential Computation
                </p>

                <p>
                    Unlike description of behavior of quantitative systems, nature of
                    computing next state of which lies in the transformation of quantitative
                    values of arguments of functions into the quantitative value of the function, i.e.,
                    literally in physical <em>modification of quantities</em>, characterizing states
                    of properties of quantitative systems, the essence of computing transitions
                    of qualitative systems from state to state, is the
                    <em>replacement of some qualitative estimates</em> of state of properties
                    with other <em>qualitative estimates</em>. And
                    this difference, in the content of the process of these computations, opens up a
                    fundamentally new way of describing the computational process of the functions of
                    the qualitative systems.
                </p>

<!--                <p>-->
<!--                    Description of the behavior of <em>quantitative</em> systems, the nature of-->
<!--                    calculating next state of which lies in the transformation of the quantitative-->
<!--                    values of arguments of the functions (i.e., in physical modification of the-->
<!--                    <em>quantities</em>, characterizing states of properties of quantitative systems)-->
<!--                    into the quantitative value of the function. But, unlike of these systems, the-->
<!--                    essence of computation of transitions of the <em>qualitative</em> systems-->
<!--                    from one state to another, is the <em>replacement</em> of some qualitative estimates-->
<!--                    of the state of properties of the quantitative systems with the other ones. And-->
<!--                    this difference, in the content of the process of that computation, opens up a-->
<!--                    fundamentally new way of describing the computational process of the functions of-->
<!--                    the qualitative systems.-->
<!--                </p>-->

                <p>
                    All observed changes of variables of models of qualitative systems are generally
                    explained by the discrete nature of these systems, fragmentary changes of state of
                    their properties and asynchronous occurrence of the situation in the systems
                    (and their models). However, these factors
                    can create challenges when calculating the algebraic expressions of the functions.
                    They arise because not all but only some of the situations described in the
                    specifications of the state equations of the variables actually exist in the
                    model (and in the groups of arguments of the functions) at the moment of computing
                    the functions, and also because of what particular proposed values the expression
                    computes as a response to the appearance or disappearance of situations in the model.
                    And these challenges must be resolved.
                </p>

                <p>
                    But the mathematical model of a dynamic system is just a collection of state equations
                    of the system, and nothing more. Therefore, this proposes that the resolution of
                    challenges should occur not outside but inside the algebraic expression, and be
                    provided by the operations used for computing the expression. This, as it was shown
                    by the study, the feasibility of implementing functions of models of qualitative
                    systems in the form of algebraic expressions is determined by the approach to
                    constructing algebraic expressions of functions, that makes the challenges surmountable.
                    This approach and its solutions are described below.
                </p>

<!--                <p>-->
<!--                    As it was shown by the study, the feasibility of implementing functions of models-->
<!--                    of qualitative systems in the form of algebraic expressions is determined by-->
<!--                    existence of certain challenges and the approach to constructing algebraic expressions-->
<!--                    of functions, that makes the challenges surmountable. They are described below.-->
<!--                </p>-->

<!--                <p>-->
<!--                    <br><br>-->
<!--                    As it was shown by the study, the feasibility of implementing functions of models-->
<!--                    of qualitative systems in the form of algebraic expressions is determined by-->
<!--                    existence of certain challenges and the model implementation solutions, suggested by the-->
<!--                    modeling technique. They are described below.-->
<!--                </p>-->

                <p>
                    (1) Since in accordance with the specification, any single states of a variable may
                    depend on existence of several different situations and all the variety of situations
                    that may cause change of all states of the variable can, in the worst case, emerge
                    independently, it is possible that during each computation of the function either
                    none or only a part of all expected situations may be present in the groups of the
                    arguments of a function. Therefore.<br/>

                    <div class="single-line-frame">
                        The task of the computation of the expression
                        is to systematically consider all described in the specification situations and
                        groups of arguments passed in the function representing current situations.
                    </div>
                </p>

                <p>
                    (2) Dependence of a value of a function on several situations assumes that the
                    process, computing values of a state variable of a model, should a) contain
                    operations which produce proposed values corresponding to situations described
                    in the specification of the state variable, and b) an operation that analyzes
                    the obtained proposed values and selects from them the only final value of the
                    function. Therefore.<br/>

                    <div class="single-line-frame">
                        In order to reflect that way of computation, performed by the expression, its
                        structure should be defined as a polynomial (or, in the other words, as the
                        "sum of products"), written in the way similar to the well known Disjunctive
                        Normal Form, yet, to be more precise, as the Extended Disjunctive Normal Form (XDNF).
                    </div>

<!--                    Dependence of value of a function on several situations assumes that the process-->
<!--                    of computing the value should contain operations which produce proposed values-->
<!--                    corresponding to each of the proposed values described in the specification of the-->
<!--                    state variable and an operation that analyzes the obtained proposed values and-->
<!--                    selects from them the only final value of the function. Therefore, to reflect that-->
<!--                    way of computation in the expression its structure should be defined as a polynomial,-->
<!--                    written in the vay similar to the well known Disjunctive Normal Form, or, to be-->
<!--                    more precise, as the Extended Disjunctive Normal Form (XDNF).-->
                </p>

                <p>
                    (3) Since the state of the model is constantly changing from iteration to iteration
                    and, thus, any knowledge about changes of situations is represented in the model
                    only by the state of its variables, revealing which of the situations, expected by
                    the expression, are present and which are absent, at the time of its computation,
                    can only be carried out by the expression itself. Therefore.<br/>

                    <div class="single-line-frame">
                        In addition to the usual ability of operations of transforming the values of their
                        arguments into result, the operations used in the XDNF expression must be endowed with
                        capabilities to a) analyze state of the arguments or data produced by other operations
                        and create estimates of their state, and b) take as operands of the operations created
                        estimates (together with the intermediate values being computed) and change yielded
                        result, depending on the state of the estimates.
                    </div>
                </p>

                <p>
                    (4) Since the estimates of the data state, originally created to control the course
                    of the computation process, may later be used instead of defined values that were
                    for some reason not computed, i.e., as the markers of undefined values, the values
                    used as the markers of the estimates should be taken from another set, elements of
                    which should be considered as auxiliary and be compatible in type with the elements
                    (i.e., symbols) of the set <b>D</b>. Therefore.<br/>

                    <div class="single-line-frame">
                        This set should be defined as a set of auxiliary symbols X = { !, $, # }, meaning of
                        which is explained as the part of description of their application.
                    </div>
                </p>

                <p>
                    (5) Technique of computing algebraic expressions does not assume  presence of any
                    variables in the expression. Dataflow, in them, is distributed from the output of
                    any executed operations directly to the input of the following operation and so on.
                    However, the operations used for computing XDNF expressions can yield results whose
                    values are taken either from the set <b>D</b>, or from the set <b>X</b>, and take
                    elements of both types as their operands as well. Therefore.<br/>

                    <div class="single-line-frame">
                        The dataflow in the XDNF expressions is formed on the basis of both types of data
                        - symbols taken from the set <b>D</b> and symbols taken from the set <b>X</b>.
                    </div>
                </p>

                <p class="third-level-section-header-bold-line-size">
                    Meaning of the Elements of Set <b>X</b>
                </p>
<!--                <p>-->
<!--                    Meaning of elements of set <b>X</b> is following:-->
<!--                </p>-->

                <p>
                    (o) the symbol "!" must be used to denote the fact of presence of the expected situation
                    in the group of arguments of the expression;
                </p>

                <p>
                    (o) the symbol "$" must be used to denote the fact of absence of the expected situation
                    in the group of arguments of the expression, and also either as a proposed value when
                    this value is indefinite because the situation that could produce it turned out to be
                    absent, or as a final proposed value when it is indefinite because simultaneously all
                    situations expected in the expression turned out to be absent and as a result none of
                    the proposed values of the variable was computed;
                </p>

                <p>
                    (o) and the symbol "#" shall be used to denote a final proposed value when it cannot
                    be determined because in the process of computing that value it was discovered that
                    two or more proposed values were different and thus a conflict of variable values arose
                    which prevented the final value from being computed as determined.
                </p>

                <p>
                    Examples of interpretation of meaning of elements of the set <b>X</b> can be expressed
                    in the form of different statements. Instances of the qualitative assessments of state
                    of a computational process are: "Situation recognized", "Situation not recognized",
                    "Proposed value not defined", "The final value of the function is not defined as none of the
                    expected situations is present in the state of the model", or
                    "The final value of the function is not defined as a contradiction
                    of proposed values is detected".
                </p>

<!--                <div class="single-line-frame">-->
<!--                <div class="definition-border">-->
<!--                    <div class="definition-inner-border" style="padding: 0px 15px 0px 15px;">-->
                        <p>
                            Described above assumptions of possibility defining functions in the form
                            of the XDNF expression and utilizing, in addition to the earlier defined
                            domain set of the functions <b>D</b>, an auxiliary set of symbols <b>X</b>
                            turned out to be not just imaginary, but the major key factor terning the
                            described trial approach into a real modeling solution of the qualitative
                            systems mathematical modeling technique.
                        </p>
<!--                    </div> &lt;!&ndash; End of definition inner border &ndash;&gt;-->
<!--                </div> &lt;!&ndash; End of definition outer border &ndash;&gt;-->

                <p class="second-level-section-header">
                    Homogeneous Carrier Set of Model and Family of<br>
                    Hybrid, Binary Operations Closed on the Set
                </p>

                <div class="single-line-frame">
<!--                <div class="definition-border">-->
<!--                    <div class="definition-inner-border" style="padding: 0px 15px 0px 15px;">-->
                        <p>
                            As it was shown by the study of feasibility of defining functions of models
                            of qualitative systems in the form of the algebraic expressions, homogeneity
                            of the sets <b>D</b> and <b>X</b>, arising in the result of defining both of
                            them as sets, whose elements are symbols, <em>creates a unique opportunity to define
                            the carrier set of the functions of a model as the union of these two sets</em>.
                        </p>
                </div>
                        <p>
                            So, the definition of the carrier set of the model as the homogeneous, i.e., as
                            <b>S</b> = <b>D</b> U <b>X</b>, based on the definition made, in turn, makes
                            it possible defining on the set <b>S</b> a family of hybrid, binary, and closed on
                            the entire set, operations, whose operands are capable of taking either the elements
                            of the set <b>D</b> or the elements of the set <b>X</b> and producing any element
                            of the set <b>S</b>.
                        </p>

<!--                    </div> &lt;!&ndash; End of definition inner border &ndash;&gt;-->
<!--                </div> &lt;!&ndash; End of definition outer border &ndash;&gt;-->

                <p>
                    Research on the feasibility of defining on the set <b>S</b> operations capable of
                    performing required computation was conducted. And its result made it possible to construct
                    five hybrid operations, letting to implement the procedure of computation of state functions
                    of variables of qualitative systems models in the form of extended disjunctive normal form
                    of the algebraic expression written as a composition of these operations. The names,
                    denoting symbols and comments on the roles of the operations in the process of
                    computation of the expression are listed in Table 1.
                </p>

                <DIV style="align: center; width: 390pt; text-align: right;">Table 1</DIV>
                <DIV><table style="width:380pt">
                    <tr>
                        <th style="width:25%">Name</th>
                        <th style="width:10%">Sign</th>
                        <th style="width:65%">Meaning</th>
                    </tr>
                    <tr >
                        <td>Equivalence</td>
                        <td>?</td>
                        <td style="text-align: center; font-size:10pt;">
                            Compares operands; yields "!" when operands are equal, or "$" when they are not.</td>
                    </tr>
                    <tr >
                        <td>Conjunction</td>
                        <td>&</td>
                        <td style="text-align: center; font-size:10pt;">
                            Works as a boolean AND operation for symbols "!" and "$". It is used to compute n-ary Conjunction.</td>
                    </tr>
                    <tr >
                        <td>Production</td>
                        <td>*</td>
                        <td style="text-align: center; font-size:10pt;">
                            Produces proposed values for all identified or not identified expected situations.</td>
                    </tr>
                    <tr >
                        <td>Disjunction</td>
                        <td>|</td>
                        <td style="text-align: center; font-size:10pt;">
                            Analyses all proposed values, chooses final value. It is used to compute n-ary Disjunction.</td>
                    </tr>
                    <tr >
                        <td>Application</td>
                        <td><</td>
                        <td style="text-align: center; font-size:10pt;">
                            Checks if the final value is an element of set <b>D</b>, and returns it; otherwise
                            returns the current value of the variable.</td>
                    </tr>
                </table></DIV>

                <p>
                    The table lists all five operations in the order they are used in the expression. Names of the
                    operations are presented in the first column of the table. The second column contains symbols
                    used to denote the operations in an expression where the operations are written in their infix
                    form. And the third column provides a brief description of the operations.
<!--                    Detailed descriptions of the operations presented in the table are listed below.-->
                </p>

            <!--   O P E R A T I O N S    -->

<!--                <p>-->
<!--                    <b>Equivalence</b> (?) operation is the first that begins computation of the procedure of a function.-->
<!--                    It is used to recognize situations, description of which is passed to a function as the groups of-->
<!--                    its arguments. When recognizing a particular situation, this operation compares all the values-->
<!--                    of a group of the arguments, which may or may not contain the description of the expected situation-->
<!--                    present in the model at the time of computation of the function, with their expected values. To-->
<!--                    perform this comparison, the operation takes two operands whose values are symbols of the set <b>D</b>-->
<!--                    and yields either symbol "!", which belongs to the set <b>X</b>, if both operands are represented by-->
<!--                    the same symbol of set <b>D</b>, or the value "~", which also belongs to the set <b>X</b>, if the operands are-->
<!--                    represented by different symbols of the set <b>D</b>.-->
<!--                </p>-->

<!--                <p>-->
<!--                    <b>Conjunction</b> (&) operation is also used to recognize situations, or more precisely to-->
<!--                    compute the indicators representing the fact that all the results of comparing the states of-->
<!--                    properties with their expected values obtained as a result of applying the Equivalence-->
<!--                    operation have been compared and thus the expected situation is recognized. It is called-->
<!--                    Conjunction because it inherits its role from the Conjunction operation defined on a set-->
<!--                    consisting of only two elements and solves the same problem. This operation takes two operands-->
<!--                    computed by the Equivalence operation by comparing its operands, each of which can be either-->
<!--                    the "!" symbol or the "~" symbol, and returns the "!" symbol only in case - when  both of its-->
<!--                    operands contain the "!" symbol, or the "~" symbol for all other combinations of operands.-->
<!--                    Properties of the commutativity and associativity of the Conjunction operation allow it to be-->
<!--                    used for computing n-ary conjunction of all results of the Equivalence operation, where the-->
<!--                    output of n-ary conjunction is the value "!" if and only if all results of the Equivalence-->
<!--                    operation are represented by the symbol "!", or the symbol "~" otherwise.-->
<!--                </p>-->

<!--                <p>-->
<!--                    <b>Production</b> (*) operation is the generator of the  proposed state of the variable. It has-->
<!--                    gotten its name because it acts in the same-->
<!--                    way as the production rule. One of the operands of this operation is the result of recognition-->
<!--                    of the situation, i.e. it may contain either symbol "!" or "~" obtained after  computation-->
<!--                    of the n-ary conjunction accomplished by the Conjunction operation. While the second argument-->
<!--                    is the element of the set <b>D</b>, that is described in the Correspondence of the specification as-->
<!--                    the proposed value of the variable. The operation produces a proposed value of the variable-->
<!--                    that is a dependent element of the relation computed by the function in case when the operand,-->
<!--                    representing the result of recognition of situation "!" indicates that the situation is recognized,-->
<!--                    or the symbol "~" when the result of recognition is the symbol "~" meaning that the situation is-->
<!--                    not recognized.-->
<!--                </p>-->

<!--                <p>-->
<!--                    <b>Disjunction</b> (|) operation is called Disjunction because in the process of-->
<!--                    computation of the function it plays a role similar to the role of the Disjunction operation-->
<!--                    of an algebra defined on a set of two elements. Its task is to look through all the proposed-->
<!--                    values and do the best to find a single "final proposed value" which should become the value-->
<!--                    of the function, and thus the next value of the state variable of the model. So, to accomplish-->
<!--                    the task this operation takes two operands that can be represented by any symbols of the set <b>S</b>.-->
<!--                    And it is commutative and associative, similar to the Conjunction operation, it is used to-->
<!--                    compute the n-ary disjunction of all the results of the Production operation. In the process-->
<!--                    of this computation, it selects from all the proposed values produced by the Production-->
<!--                    operation a single final proposed value that should become the value  of the function (and the-->
<!--                    next value of the state variable of a model) if such a value can be found among all the-->
<!--                    proposed values produced as corresponding to all situations, regardless of whether-->
<!--                    the situation is recognized or not. There are three possible outcomes of the application of-->
<!--                    this operation produced as a final proposed value. Based on the following three rules.-->
<!--                </p>-->

<!--                <p>-->
<!--                    1) It yields symbol "~" when it turns out that none of the expected situations that are-->
<!--                    independent elements in relation to the dependence of the variable on the situation were-->
<!--                    recognized since none of them are present in the state of the function arguments;-->
<!--                </p>-->

<!--                <p>-->
<!--                    2) It yields a symbol "d" that is an element of the set <b>D</b>, produced by the Production operation,-->
<!--                    as corresponding to the recognized situations in the case when one or more expected situations-->
<!--                    turned out to be present in the state of the arguments of a function and all recognized-->
<!--                    situations (when there are several of them) have produced the same proposed value of the variable.-->
<!--                </p>-->

<!--                <p>-->
<!--                    3) Or, it yields the symbol "#" denoting the case when at least two of the expected situations-->
<!--                    are present in the model (and the arguments of a function) and are recognized, but corresponding-->
<!--                    to the situations proposed values require the computed variable to simultaneously take-->
<!--                    different values. And since the function, by definition, can compute only one value, it is-->
<!--                    interpreted by the next operation as the fact that the final proposed value that this operation-->
<!--                    should produce could not be found among the previously computed proposed values. And.-->
<!--                </p>-->

<!--                <p>-->
<!--                    <b>Application</b> (<) operation is the last one in the procedure of computation of a function.-->
<!--                    Yet, its role has nothing to do with the continuation of computation of the function. It is used-->
<!--                    to redefine the function by transforming it from partially defined to defined on all possible-->
<!--                    combinations of its arguments (whether they represent or not represent situations) and, thus,-->
<!--                    for eliminating cases when, due to a conflict of values detected by the Disjunction-->
<!--                    operation, the final value turned out to be undefined; that is, to transform a partially defined-->
<!--                    function into a complete one. In solving this problem, the Application operation, like all previous-->
<!--                    operations, also takes two operands. But unlike all previous operations, it is not commutative.-->
<!--                    Its first operand is the final proposed value (computed or not by the Disjunction operation),-->
<!--                    and the second is an additional argument of the function containing the current value of the-->
<!--                    variable, in case the computation of the next value of the variable may not work. Thus, all this-->
<!--                    operation does is check the type of the final proposed value of the function passed to it as-->
<!--                    its first operand and determine the computed value of the function using the final proposed value-->
<!--                    if that value is represented by an element of the set <b>D</b>, i.e., is a real symbol representing-->
<!--                    the next state of the variable. Or, alternatively, use the value of the additional argument of-->
<!--                    the function which is the current value of the function which should replace the unevaluated-->
<!--                    final proposed value.-->
<!--                </p>-->

                <p>
                    Complete description of the sets <b>D</b>, <b>X</b>, and <b>S</b>, as well as of the
                    five operations defined on the set <b>S</b>, that all together constitute the algebraic
                    system, is presented on the page
                    <span class="popup-link" onmouseenter="openPopup(event, popup04)"
                          onmouseleave= "closePopup(popup04)">
                        <a class="popup-link" href = "../kp-aos/kp-aos.html" target="_blank">
                    <em>"The Algebra of Symbols"</em></a></span>.
                </p>

                <p class="second-level-section-header">
                    General Form of State Equation of Model Defined as<br>the Expanded Disjunctive Normal Form - XDNF
                </p>

                <p>
                    The general form of a state equation of a variable whose right-hand side function
                    is implemented as the XDNF expression written as a composition of hybrid operations
                    defined on the model's carrier set <b>S</b> can be presented as the formula.
                </p>

<!--                <p>-->
<!--                    The general form of a state equation of a variable whose right-hand side is defined as an-->
<!--                    algebraic expression written as a composition of hybrid operations defined on the model set-->
<!--                    <b>S</b> can be written as the formula.-->
<!--                </p>-->
                <p>
                <img  class="center" src="images/xdnf-formula.png" width="450" height="50" alt="">
                </p>

                <p>
                    The arguments of this expression are variables representing the current state of
                    a model and constants taken from the model variable dependency specification.
                    They are passed to the function as: 1) a list <b>gv</b>, elements of which are groups of
                    variable some concrete combinations of values of which can characterize situations
                    expected by the function, 2) a list <b>ev</b> elements of which are groups of expected
                    values of variables, given in the groups of array <b>gv</b>; they are used to recognize
                    combinations of values characterizing expected situations that may be present in
                    the groups of variable of array <b>gv</b>, 3) a list <b>pv</b> holding proposed values
                    of computed variable, corresponding to the expected situations, and 4) a constant
                    <b>sv</b> that serves as the spare value holding current state of the computed state
                    variable, which should be used when computed value turns out be undefined.
                </p>

                <p class="third-level-section-header-bold-line-size">
                    Computation of Expanded Disjunctive Normal Form Equation
                </p>

                <p>
                    Computation  of this equation can be described as performing Disjunction operation
                    that yields value of the function as result obtained via processing all proposed
                    values generated as a result of computing all terms of the expression. Whereas the
                    computation of each particular term is accomplished as execution of the Production
                    operation that generates proposed values of the variable either as constant taken
                    from the array <b>pv</b>, when expected situation is recognized, or as the auxiliary
                    symbol $, when the situation is not recognized. Meanwhile, the recognition is carried
                    out by two operations: Equivalence and Conjunction. First of them - Equivalence
                    performs by-element comparison of the variables of the group of array <b>gv</b>
                    with their expected values represented by the constants in the groups of array <b>ev</b>.
                    And the Conjunction operation is used to confirm that all results of comparison of
                    all elements of both groups of both arrays are compared and, thus, the situation can
                    be deemed recognized.
                </p>

                <p>
                    Ultimately, since (as it was discussed earlier) the final proposed value
                    yielded by the Disjunction operation may be undefined, the last operation that completes
                    the computation, is the Application operation; it is denoted by the symbol "<". This
                    operation checks the result of the Disjunction operation and, in the case when it is
                    undefined, uses the value of the last spare argument of the function - <b>sv</b>, containing
                    the current value of the computed variable, instead of the undefined result of
                    computation. And, as a consequence of this replacement, the computed variable of the
                    equation receives the same value that it already holds again and, thus, effectively
                    remains unchanged.
                </p>

                <p>
                    XDNF Expressions Calculator is presented on the page
                    <span class="popup-link" onmouseenter="openPopup(event, popup05)"
                          onmouseleave= "closePopup(popup05)">
                        <a class="popup-link" href = "../kp-xdnf/xdnf-expression-calculator.html" target="_blank">
                    <em>"Extended Disjunctive Normal Form Expression Calculator"</em></a></span>.
                </p>

                <p>
                    More detailed description of the process of computation of the XDNF expression is
                    provided in two following sections. They present several examples of computing the
                    only expression with different values passed to it as arguments. The examples are used
                    for illustrating and describing steps of the execution of the expression, so to speak,
                    in the "debugging" mode.
                </p>

<!--                <p>-->
<!--                    Being a general form of the expression, this formula states that:-->
<!--                </p>-->

<!--                <p>-->
<!--                    (a) The value of the variable x<sub>i</sub> at time t+1 is computed as an expression of the Algebra of-->
<!--                    Symbols defined as a composition of five operations defined on the set <b>S</b>.-->
<!--                </p>-->

<!--                <p>-->
<!--                    (b) Following the requirement to keep values of variable x to be denoted by only elements of-->
<!--                    domain set <b>D</b> and the QVDSpec the structure of the expression. written from left to right,-->
<!--                    (which is opposite to the order of execution of operations) begins with the sign "<"  that-->
<!--                    indicates Application operation task of which is to protect value of the variable in case when-->
<!--                    its next value is not defined,-->
<!--                </p>-->

<!--                <p>-->
<!--                    (c) The structure of the formula placed in curly braces is determined by the specification.-->
<!--                    The part of expression in it, written as Disjunction from c = 0 to cn(i) of elements written-->
<!--                    in the square brackets is the cn(i)-ary disjunction, where cn(i) is the number of Correspondence-->
<!--                    computing proposed values of the variable x<sub>i</sub> and part in the square brackets is the general-->
<!--                    form of the sub-expression computing proposed values pv(i, c), where pv(i, c) stands for element-->
<!--                    of set <b>S</b> that should be used as the proposed value generated by the c-th Correspondence of the-->
<!--                    i-th variable, that should be used as one of the operands of operation Production, denoted-->
<!--                    by symbol "*".-->
<!--                </p>-->

<!--                <p>-->
<!--                    (d) The part located on the right side of the Production operation, written as Conjunction-->
<!--                    from s = 0 to sn(i) is the sn(i)-ary conjunction of the results of Equivalence (?) operation.-->
<!--                    Here sn(i) is the number of pairs: argument[i,c,k]/ev[i,c,k]  which characterize i,c-th situation.-->
<!--                </p>-->

<!--                <p>-->
<!--                    (e) The parts of the pair: argument[i,c,k] is the i,c,k-th argument of the expression and the-->
<!--                    ev[i,c,k] is the i,c,k-th element of set <b>S</b> used to represent expected value of the i,c,k-th-->
<!--                    argument of the expression. These pairs: argument[i,c,k]/ev[i,c,k] serve as the operands of-->
<!--                    the Equivalence operation.-->
<!--                </p>-->

                <!-- ########################################################################################### -->
                <!--       E X A M P L E   O F   S P E C I F I C A T I O N   A N D   C O M P U T A T I O N       -->
                <!-- ########################################################################################### -->

                <p class="section-header">
                    Illustrative Example of State Equation and Process of Computation of
                    State Variable of Equation
                </p>

                <p>
                    This section presents the process of creating a model of a qualitative dynamical system
                    as a sequence of steps: creating a description of behavior of a modeled
                    system in the form of QMBSpec, creating a model of a qualitative system based on
                    QMBSpec. Then it demonstrates, process of using the created state function of the
                    variable on the example of four experiments of computation of the value of the state
                    variable of the model for different initial states of the variable and arguments
                    of the function computing different states of the variable for different arguments.
                </p>

    <!--                ////////////////////////////////////////////////////////  -->

<!--                <p class="second-level-section-header">-->
<!--                    Example of the QMBSpec having Single QVDSpecs-->
<!--                </p>-->

<!--                <div class="definition-border">-->
<!--                    <div class="definition-inner-border" style="padding: 0px 15px 0px 15px;">-->
<!--                        <p class = "formula">-->
<!--                            x0 : [K : {(x1 : A), (x2 : B)}];  [L : {(x3 : M)}];  [H : {(x4 : E), (x5 : D), (x6 : N)}]-->
<!--                        </p>-->
<!--                    </div> &lt;!&ndash; End of definition inner border &ndash;&gt;-->
<!--                </div> &lt;!&ndash; End of definition outer border &ndash;&gt;-->

<!--                <p>-->
<!--                    Presented example describes dependence of a single variable x0 whose values depend on three Correspondences.-->
<!--                    The first Correspondence  [K : {(x1 : A), (x2 : B)}] states that variable x0 should take value K,-->
<!--                    when the values of the variables x1 and x2 hold expected values A and B. The second Correspondence-->
<!--                    [L : {(x3 : M)}] states that variable x0 should take value L, when the value of variable x3 holds-->
<!--                    expected values M. And the third Correspondence  [H : {(x4 : E), (x5 : D), (x6 : N)}] states that-->
<!--                    variable x0 should take value H, when the values of the variables x4, x5 and x6 take expected values-->
<!--                    E, D and N.-->
<!--                </p>-->

<!--                <p>-->
<!--                    This example will be used later to illustrate the process of computation of the state equation-->
<!--                    of the variable x0 whose expression is defined on the basis of the specification presented-->
<!--                    in this section.-->
<!--                </p>-->

    <!--                ////////////////////////////////////////////////////////  -->

                <p class="second-level-section-header">
                    Example of State Equation Implemented as the XDNF<br>Expression
                </p>

                <p>
                    Presented example of an equation defined in accordance with above formula describing dependence of
                    values of a variable "x0" on the combinations of values of variables x1, x2 and x3 which
                    characterize two situations (x1), and (x2, x3) that may arise in a particular system, is
                    presented as equation.
                </p>

                <p style = "text-align: center;">
                    x0 = x0 < [ ( P * (x1 ? E) )  |  ( H * ( (x2 ? M) & (x3 ? Q) ) ) ];&nbsp;&nbsp;&nbsp;(1)
                </p>

                <p>
                    This simple equation states that the two values which variable x0 can take are determined by
                    two situations and hence two correspondences. The first (left to right) Correspondences
                    describes that variable x0 should take value P when value of variable x1 is E, whereas the
                    second Correspondence  describes that variable x0 should take value H when value of variable
                    x2 is M, while the value  of variable x3 is simultaneously marked by symbol Q. In spite of
                    such simple dependence, different combinations of values of independent variables (arguments)
                    of the expression: x1, x2 and x3 may cause the expression can be computed with different
                    results and thus would create at least three different values of the variable x0. All these
                    cases are considered and illustrated in the next section, which describes every single step of
                    the computation of the expression in all the details.
                </p>

    <!--                ////////////////////////////////////////////////////////  -->

                <p class="second-level-section-header">
                    Computation of State Variable of XDNF Equation
                </p>

                <p>
                    Content of the illustrations, presented in this section, is based on the simple
                    equation (1), right part of which is defined as XDNF expression. Four different
                    ways of computation of this equation is illustrated as four examples A, B, C, and D.
                </p>

                <p>
                    All four examples illustrate the process of computing the value of dependent variable
                    x0, of the equation, with four different combinations of values of two groups of
                    arguments, where the first group consists of variable x1, while second one consists
                    of variables x2 and x3. Each of the examples is shown as seven lines. Therefore, in
                    order to show how the expression computes different results, the first line presents
                    result of initialization of the computed value x0 with the same value G in all examples,
                    but variables: x1, x2 and x3 with different values in each example.Second line is the
                    initial state of the equation. Lines three through six present results of execution of
                    operations: Equivalence, Conjunction, Production and Disjunction. And finally, the
                    seventh, and the last,  line presents the result of execution of Application operation, which
                    is the final proposed value of the variable x0 computed by the expression.
                </p>

                <p>
                    Below is the first example A, followed by the detailed description of steps of execution
                    of the operations.
                </p>

<!--                <p>-->
<!--                    Proposed in previous sections, solutions for modeling qualitative dependencies, based on the-->
<!--                    hybrid set <b>S</b>, make it possible to describe dependence of changes of values of a qualitative-->
<!--                    variable on various emerging and disappearing situations. An example, presented in (1),-->
<!--                    represents such dependence in the form of algebraic equation, utilizes elements of the set-->
<!--                    <b>S</b> for denoting values of variables, and computes the algebraic expression, located in the-->
<!--                    right part of the equation, as the composition of operations defined on the set <b>S</b>. The-->
<!--                    content of this section is to illustrate application of auxiliary and domain elements of-->
<!--                    the set <b>S</b> as well as operations defined the set in the process of computation of-->
<!--                    the expression of the equation (1). Computation of this equation is illustrated in four examples.-->
<!--&lt;!&ndash;                    The content of the proposed example is presented in Figure 4 which has four sections: a, b,&ndash;&gt;-->
<!--&lt;!&ndash;                    c and d.&ndash;&gt;-->
<!--                </p>-->

<!--                <p>-->
<!--                    All four example illustrate process of computing value of dependent variable x0, of the-->
<!--                    equation, with four different combination of values of two groups of arguments,-->
<!--                    where the first group consists of variable x1, while second one consists of variables-->
<!--                    x2 and x3. Therefore, in order to show how the expression computes different results,-->
<!--                    each of the four sections begins with the initialization of the computed value x0 with-->
<!--                    always the same value G, but with each time different values of the variables:-->
<!--                    x1, x2 and x3.-->
<!--                </p>-->

<!--                <p>-->
<!--                    Six lines, in each example, presented right below the line of initialization, depict-->
<!--                    initial state of the expression followed by the lines results of successive steps of-->
<!--                    the execution of five operations: ?, &, *, | and <, which yield intermediate values-->
<!--                    of the process of computation of the expression. These values are depicted in-->
<!--                    the diagrams as a replacement of part of the executed expression which holds the construct:-->
<!--                    "operand-operation-operand" by the value produced by this operation. The arrows drawn-->
<!--                    vertically downwards, in the first diagram, are directed from the sign of the executed-->
<!--                    operation to the symbol representing result of the operation. The arrows are drawn only in-->
<!--                    the first diagram and serve for attracting attention to the operation performed. But they-->
<!--                    are not present in the remaining three diagrams, since all of them, depict the same-->
<!--                    execution process. Difference in the content of computation of the last tree examples-->
<!--                    is determined by different initial values assigned to the arguments of the expression at-->
<!--                    time of their initialization. Here below is the fist example followed by the detailed-->
<!--                    description of steps of execution of the operations.-->


<!--                </p>-->
<!--                located on the next-->
<!--                line representing result of executed step.-->
<!--                line representing result of executed step,-->
                <!--                ////////////////////////////////////////////////////////  -->

                <p class = "second-level-section-header" >
                    Detailed Description of Roles of the Operations and<br> Steps of Computation of Example A
                </p>

                <p>
                    <img class="center" src="images/example-0.png" width="512" height="230" alt=""/>
                </p>
                <p style = "text-align: center;">
                    <b>Figure 2.</b> Example A. The application of these operations is depicted
                    in this figure by an arrows drawn from the signs of operations to their result.
                </p>

                <p>
                    This figure provides a detailed description of the steps of computation of the expression.
                    It illustrates case when the arguments of the expression are initialized as: x0 = G;
                    x1 = L; x2 = M; x3 = Q. And, thus, the situation (x1) is appeared not present and not
                    recognized, whereas the situation (x2, x3) is present and recognized. Therefore, the
                    only proposed value "H" produced by the Production operation, as the correspondence
                    to the situation (x2, x3) is the one that can be chosen by the Disjunction operations
                    as the final proposed value and then accepted by the Application operation. So, that
                    value "H" becomes the value of the variable x0.
                </p>

                <p>
<!--                    Step 1. Equivalence operation is defined as yielding an auxiliary symbol "!" of set X -->
<!--                    when both of its operands are represented by the same symbol of set D, or another -->
<!--                    auxiliary symbol $ of set X when the values of the operands are different. Therefore, -->
<!--                    in the context of this example, the Equivalence operation is used to compare value of -->
<!--                    argument x1 with its expected value, and yields symbol "$", since this value is not -->
<!--                    the same as expected value "E"; as well as for comparing the values of the argument -->
<!--                    x2 and x3 with their expected value, and yields, in both cases, symbol "!", since both -->
<!--                    these values are the same as their expected values "M" and ?N?.-->

                    <em>Step 1</em>. Equivalence operation is defined as yielding an auxiliary symbol "!" of set X
                    when both of its operands are represented by the same symbol of set D, or another
                    auxiliary symbol $ of set X when the values of the operands are different. Therefore,
                    in the context of this example, the Equivalence operation is used to compare value of
                    argument x1 with its expected value, and yields symbol "$", since this value is not
                    the same as expected value "E"; as well as for comparing the values of the argument
                    x2 and x3 with their expected value, and yields, in both cases, symbol "!", since both
                    these values are the same as their expected values "M" and ?N?.
                </p>

<!--                <p>-->
<!--                    Step 1. Equivalence operation is defined as yielding an auxiliary symbol "!" of set X-->
<!--                    when both of its operands are represented by the same symbol of set D, or another-->
<!--                    auxiliary symbol $ of set X when the values of the operands are different. The-->
<!--                    application of this operation is depicted in the figure by an arrow drawn from the-->
<!--                    operation sign "?" to its result, which is designated by the symbol produced by the-->
<!--                    operation in accordance with its definition. Therefore, in the context of this example,-->
<!--                    the Equivalence operation is used three times. It 1) compares the value of argument-->
<!--                    x1 with its expected value, and yields symbol "$", since this value is not the same-->
<!--                    as expected value "E"; 2) compares the value of the argument x2 with its expected-->
<!--                    value, and yields symbol "!", since this value is the same as expected value "M"; and-->
<!--                    3) compares the value of argument x3 with its expected value, and yields symbol "!",-->
<!--                    since this value is the same as expected value "N".-->
<!--                </p>-->

<!--                <p>-->
<!--                    Step 1. Equivalence operation is defined as yielding an auxiliary symbol "!" of set X-->
<!--                    when both of its operands are represented by the same symbol of set D, or another-->
<!--                    auxiliary symbol $ of set X when the values of the operands are different. Therefore,-->
<!--                    in the expression, it is used three times: to compare the value of the argument x1-->
<!--                    with its expected value E, and the values of the arguments x2 and x3 with their-->
<!--                    expected values T and K. The application of this operation is depicted in the figure-->
<!--                    by arrows drawn from the operation sign "?" to its result, which is designated by-->
<!--                    the symbol produced by the operation in accordance with its definition. In the context-->
<!--                    of this example, results of the Equivalence operation are: a) symbol $, since the-->
<!--                    symbol of variable x1 is not the same as its expected symbol "E", and b) two symbols-->
<!--                    "!", since symbol of variable x2 is the same as its expected symbol "M", and state of-->
<!--                    variable x3 is the same as its expected symbol "N".-->
<!--                </p>-->

<!--                <p>-->
<!--                    Step 1 is performed as the execution of the Equivalence (?) operation which is applied to-->
<!--                    the situation (x1), presented as a group of variables consisting of only one variable x1,-->
<!--                    and to the situation (x2, x3), presented as a group consisting of two variables x2 and x3.-->
<!--                    So, as it follows from the structure of the expression, the task of this operation is to-->
<!--                    test if the current value of each variable is the same as its expected one.  In Figure 4a,-->
<!--                    the application of this operation is depicted as three arrows directed vertically from the-->
<!--                    sign of the Equivalence operation "?" to the symbol yielded as the result depending on the-->
<!--                    operands of the operation. Thus, as the value of the variable x1 is "L" and its expected-->
<!--                    value is "E" the application of the Equivalence operation to these operands yields the-->
<!--                    symbol of "$" - indicating that the value "L" of operand x1 and constant "E" are not the same.-->
<!--                    Yet, at the same time, the value "M" of variable x2 is the same as the constant "M" and-->
<!--                    the value "Q" of the variable x3 is the same as the constant "N". Hence, application of-->
<!--                    the Equivalence operation to both pairs of the second situation yields the auxiliary symbol "!".-->
<!--                </p>-->

                <p>
<!--                    Step 2. Although the Conjunction operation is defined on a set whose cardinality -->
<!--                    can be much greater than 2, its application to operands and result that can only -->
<!--                    be the symbols "!" and "$" completely replicates the behavior of the well-known -->
<!--                    Conjunction operation defined on a set consisting of only two elements. Therefore, -->
<!--                    in the context of this example, the Conjunction operation is used only once. It -->
<!--                    takes the results of the Equivalence operation, each of which in this case is -->
<!--                    represented by the symbol "!" and produces the symbol "!" confirming that the expected -->
<!--                    situation is present in the model and, thus, is recognized.-->

                    <em>Step 2</em>. Although the Conjunction operation is defined on a set whose cardinality
                    can be much greater than 2, its application to operands and result that can only
                    be the symbols "!" and "$" completely replicates the behavior of the well-known
                    Conjunction operation defined on a set consisting of only two elements. Therefore,
                    in the context of this example, the Conjunction operation is used only once. It
                    takes the results of the Equivalence operation, each of which in this case is
                    represented by the symbol "!" and produces the symbol "!" confirming that the expected
                    situation is present in the model and, thus, is recognized.
                </p>
<!--                <p>-->
<!--                    Step 2 is performed by the Conjunction (&) operation. The task of this operation is to compute-->
<!--                    the conjunction of all results of the Equivalence operation and thus show that all the-->
<!--                    current values of the independent variables characterizing the situation have been compared with-->
<!--                    the expected ones and therefore the expected situation is present in the state of the model-->
<!--                    and thus is considered as recognized. So, this operation is used to conduct the test for the-->
<!--                    results of the Equivalence operations yielded for each situation. So, to confirm the recognition,-->
<!--                    the operands of the Conjunction operation may be different combinations of symbols "!" and "$"-->
<!--                    therefore the role of the operation is, in respect to the values of operands, is absolutely the-->
<!--                    same as the behavior of the well known boolean Conjunction operating with the values named "true"-->
<!--                    and "false". The application of this operation, in the considered case, is depicted as one arrow-->
<!--                    directed from the sign "&" of this operation to the symbol yielded as its result; in this case it-->
<!--                    is symbol "!".-->
<!--                </p>-->

                <p>
                    <em>Step 3</em>. The task of the Production operation either consists in producing the proposed
                    value of the variable corresponding to the recognized situation or in marking the
                    produced proposed value with an auxiliary symbol indicating that the proposed value
                    is undefined, when the situation is not recognized. Therefore, in the context of this
                    example, Production operation takes its operands as the constant "P" and the result
                    of recognition of the situation of the term, and yields symbol $ since the result of
                    recognition of the situation is marked with symbol $, indicating that the situation
                    is not recognized.
                </p>

<!--                <p>-->
<!--                    Step 3 is performed by the Product (*) operation. The output of this operation is a proposed-->
<!--                    value that is produced as the correspondence to recognized or not recognized situation. Depending-->
<!--                    on the result of the recognition of situation performed by the Equivalence and Conjunction-->
<!--                    operations, the proposed value produced by the Production operation may be presented as either-->
<!--                    the constant corresponding to the recognized situation described in the Correspondence sub-expression-->
<!--                    and located as the operand of the Production operand placed on the left side of the operation,-->
<!--                    or as the symbol "$" already used to indicate the fact that the situation was not recognized.-->
<!--                    On the Figure 4a, application of the Production operation is depicted as one arrow directed from-->
<!--                    the sign "*" to the domain symbol "H" yielded as result of the application of the operation to-->
<!--                    its operands, given as symbols of "H" and "!".-->
<!--                </p>-->

                <p>
                    <em>Step 4</em>. This step is performed by the Disjunction operation, task which consists in
                    choosing final proposed value of the expression that is determined by analyzing all
                    proposed values produced by Production operation, taking into account that some proposed
                    values may be defined while the otters undefined due to the absence of some situations;
                    as well as marked as undefined by the  operation itself. Therefore, in the context of
                    this example, the Disjunction operation is applied only once. It takes two proposed
                    values denoted by the symbols $ and H and chooses from them symbol H which outputs as
                    the final proposed value of the expression.
                </p>

<!--                <p>-->
<!--                    Step 4 is performed by the Disjunction (|) operation. The execution of this step begins when-->
<!--                    all proposed values of a variable are already determined by the three previous steps,-->
<!--                    and consists in choosing the final proposed value out of all produced proposed values. So, to-->
<!--                    accomplish that choice the Disjunction operation analyzes all the proposed values one by one-->
<!--                    and selects from them the only final value of the computation process that serves as a candidate-->
<!--                    to become the next value of the variable. Therefore, as it is defined by the mechanism of this-->
<!--                    operation, its result can be yielded as either a) an auxiliary symbol "$", indicating the fact-->
<!--                    that none of the expected situations is recognized, b) an element of the set <b>D</b>, when one or more-->
<!--                    situations are recognized and all produced as the correspondence to recognized situations proposed-->
<!--                    values are represented by the same element of the set <b>D</b>, or c) an auxiliary symbol "#", indicating-->
<!--                    the fact that two or more of the recognized situations produced proposed values represented by the-->
<!--                    different elements of the set <b>D</b>, and thus created the conflict in choosing the single final value-->
<!--                    of computation. In Figure 4a the Disjunction operation takes operands given as symbols "$" and "H"-->
<!--                    and therefore chooses of them as the final proposed values symbol "H";-->
<!--                </p>-->

                <p>
                    <em>Step 5</em>. The role of the Application operation is obvious and is to yield either the
                    computed value of an expression when it is defined, or current value of the variable
                    when the computed value is undefined. Therefore, in the context of this example,
                    Application operation takes  the final proposed value, computed by the Disjunction
                    operation, as its one operand; the current value of the variable, as its second operand;
                    determines that the final proposed value is represented by the symbol "N" and, thus, i
                    s defined; and yields "N" symbol as the computed value of the variable, leaving the
                    current value of the variable "G" unused.
                </p>

<!--                <p>-->
<!--                    Step 5 is performed by the Application (<) operation. This operation is the guard of the computed-->
<!--                    value of the variable of the equation. It takes two operands: the current value of the variable-->
<!--                    and the final proposed value - produced by the Disjunction operation, which can be either the-->
<!--                    element of the set <b>D</b> or the one of the symbols of the set <b>X</b>. Following its role of guarding, this-->
<!--                    operation is to prevent any symbol, other than those that represent the valid next value of the-->
<!--                    variable, from becoming the result of the computation of the expression. So, the operation checks-->
<!--                    if the final proposed value, given to it as the operand is a symbol of set <b>D</b> and if it is then-->
<!--                    yields the  final proposed value, or otherwise (when the final proposed value is a symbol belonging-->
<!--                    to set <b>X</b> indicating that the next value of the variable is not computed) yields the first operand-->
<!--                    representing the variable's current value, that leads to the value of the variable in fact will be-->
<!--                    left unmodified. In the Figure 4a the yielded by the Disjunction operation result is represented-->
<!--                    by symbols "H", therefore next computed value of the variable is computed as the symbol "H"-->
<!--                </p>-->

<!--                <p>-->
<!--                    Execution of step 5 completes the description of computation of the expression,-->
<!--                    presented in Figure 2A.-->
<!--                </p>-->

                <p class = "second-level-section-header" >
                    Description of Computation of Examples: B, C, and D
                </p>

                <p>
                    The computation of the rest of the examples: "B", "C", and "D" follows the same
                    schema of computation as was described for the first example "a", and are different
                    only in the way of initialization of the variables: x1, x2, x3, that make the expression,
                    despite the same operations and the same number of steps to compute the different values
                    of the target variable x0 of the expression. That difference is explained by different
                    internal analysis, conducted by the operations that make them to produce different
                    values of the variable corresponding to different situations present in the arguments of
                    the expression, as they are initialized differently. These differences in the computation
                    of expression are described for each example individually.
                </p>

                <img class="center" src="images/example-1.png" width="512" height="152" alt="" />
                <p style = "text-align: center;">
                    <b>Figure 3.</b> Example B.
                </p>
                <p>
                    This figure illustrates case when arguments of the expression initialized as: x0 = G; x1 = E; x2 = M;
                    x3 = Q; These settings make both: the situation (x1) and the situation (x2, x3) are recognized, and,
                    as the consequence of that, the produced proposed values "P" and "H" create uncertainty in
                    choosing the final proposed value of variable x0. Therefore, Disjunction operation marks the final
                    proposed values by symbol "#", indicating, thus, that it is not determined. And. in the end,
                    Application operation leaves the current value "G" of the variable
                    x0 unchanged.
                </p>

                <img class="center" src="images/example-2.png" width="512" height="155" alt="" />
                <p style = "text-align: center;">
                    <b>Figure 4.</b> Example C.
                </p>

                <p>
                    This figure illustrates the case opposite to the case 2a. Here, the arguments of the expression
                    are initialized as  x0 = G; x1 = E; x2 = U; x3 = Q; and this leads to the fact that the situation
                    (x1) is recognized, but the situation (x2, x3) is not. Hence, the only proposed values "P",
                    produced by the Production operation, can be chosen by the Disjunction operation as the
                    final proposed value and becomes the value of the variable x0.
                </p>

                <img class="center" src="images/example-3.png" width="512" height="157" alt="" />
                <p style = "text-align: center;">
                    <b>Figure 5.</b> Example D.
                </p>

                <p>
                    This figure illustrates a case similar to the case 2b. Here the arguments are initialized as
                    x0 = G; x1 = R; x2 = M; x3 = Z. And this makes that none of the expected situations are
                    present in the arguments and, hence, none of them are recognized. So, both proposed values
                    of the variable, produced by the Production operation, are represented by the auxiliary symbol
                    "$". And therefore, similar to the case 2b, the Application operation leaves the value of
                    the value of the variable x0 in its current state "G".
                </p>

<!--                <p class = "section-header" >-->
<!--                    Other Pages of the Kaleidoscope Project Are:-->
<!--                </p>-->
<!--                <ul class="justified-text">-->

<!--                    <li><a href="aos.html">-->
<!--                        The Algebra of Symbols.-->
<!--                    </a>-->
<!--                    </li>-->

<!--                    <li><a href="mcln-mf.html">-->
<!--                        The Multicolored Logical Net - A Qualitative Systems Graphical Modeling Formalism.-->
<!--                    </a>-->
<!--                    </li>-->

<!--                    <li><a href="math-modeling.html">-->
<!--                        Extended Disjunctive Normal Form Expression Calculator.-->
<!--                    </a>-->
<!--                    </li>-->

<!--                    <li><a href="math-modeling.html">-->
<!--                        Qualitative Dynamical Systems Vector Space Representation and Calculator.-->
<!--                    </a>-->
<!--                    </li>-->

<!--                    <li><a href="math-modeling.html">-->
<!--                        Qualitative Dynamical Systems Modeling & Simulation Environment.-->
<!--                    </a>-->
<!--                    </li>-->

<!--                    <li><a href="math-modeling.html">-->
<!--                        Space Exploration Mission Agent Behavior Simulator.-->
<!--                    </a>-->
<!--                    </li>-->

<!--                    <li><a href="math-modeling.html">-->
<!--                        Download Kaleidoscope Project Applications.-->
<!--                    </a>-->
<!--                    </li>-->
<!--                </ul>-->

<!--                <p>-->
<!--                    And as it often happens, obtaining an answer to one question may immediately pave the road-->
<!--                    to the emergence of the next one, a more general question. So, obtaining the answers to two-->
<!--                    questions, asked at the beginning of this page, immediately sparks interest in getting the-->
<!--                    answer to the new question: How should the models of the qualitative systems be organized.-->
<!--                    All the remaining pages of the description of the project are devoted to answering this question.-->
<!--                    And the description of this starts right on the next page providing the more formal definition-->
<!--                    to described on this page set <b>S</b> and its five operations as the algebra, named "The Algebra of-->
<!--                    Symbols" and continues as presentations of other modeling solution proposing representation of-->
<!--                    the system of qualitative equations of the model based on the Vector State Space approach and-->
<!--                    the Graph Based Multicolored Logical Net (McLN) modeling formalism, creation of which is-->
<!--                    supported by the application named Qualitative Systems Modeling and Simulating Environment.-->
<!--                </p>-->

                <!-- =================================================================================================== -->
                <!-- =================================================================================================== -->
            </div> <!-- end of content holder  -->
        </div> <!-- end of text-container -->


        <!-- =================================================================================== -->

        <p>
            <a href="../kp-qds/kp-qds.html">
                <img src="../common/images/prev.png" alt="Previous Page"></a>

            <a style="margin-left: 7pt;margin-right: 7pt;"  href="../index.html#sec.2.0">
                <img src="../common/images/up.png" alt="Main Page"></a>

            <a href="../kp-aos/kp-aos.html">
                <img src="../common/images/next.png" alt="Next Page"></a>
        </p>

        <p>
            <div class="end-of-page-red-line-1"></div>
            <div class="end-of-page-red-line-2"></div>
            <div class="space-below-footer"></div>
        </p>

    </div> <!-- End of Main Container -->

    <!-- =================================================================================== -->
    <!--  P O P   U P S -->
    <!-- =================================================================================== -->

        <!--  -->
        <!--  -->
        <!--  -->
        <div class="popup-style" id="element01ToPopup" >
            <div style="text-align: center;">
                <b>Page: Qualitative Dynamical Systems, Their Behavior<br> and Mathematical Modeling</b>
            </div>
            <p >
                Objective of this page is to introduce notion of class of Qualitative Dynamical Systems
                and to describe characteristics of the nature and behavior of Qualitative Dynamical Systems,
                constituting foundation for creating mathematical models of these systems. The page
                identifies atomic element of behavior of these systems and describes basic ways of composition
                of the elements letting the models of the systems to be capable of reproducing various
                forms of behavior, observed in the qualitative dynamical systems.
            </p>
            <p class="clickable-link">
                Clicking the link opens named page in a new tab.
            </p>
        </div>

        <!--             -->
        <!-- p o p u p s -->
        <!--             -->
        <div class="popup-style" id="element02ToPopup">
            <div style="text-align: center;">
                <b>Page: Multicolored Logical Net Modeling Formalism</b></div>
            <p>
                The Page, titled: "Multicolored Logical Net Modeling Formalism", or McLN MF,
                is the means enabling development of the qualitative systems simulation models in
                the form of graphically depicted net. Elements of this net represent properties of
                the modeled system, whereas the simulation process reproduces changes of the states
                of the properties as changes of the colors of the depicted elements.
            </p>
            <p class="clickable-link">
                Clicking the link opens named page in a new tab.
            </p>
        </div>

        <!--  -->
        <!--  -->
        <!--  -->
        <div class="popup-style" id="element03ToPopup">
            <div style="text-align: center;">
                <b>Section: Qualitative System Behavior Specification</b>
            </div>
            <p>
                This section is located on the page: "Qualitative Dynamical Systems, Their Behavior and Mathematical Modeling
                Technique". It proposes a way of describing behavior of particular qualitative
                dynamical system by listing rules of dependence of each state of each property
                of the system on the state of groups of properties, occurrence of which causes
                transition of the dependent property from its current to the next state, which is
                deemed the "proposed state of the property", provided by the rule.
            </p>
            <p class="clickable-link">
                Clicking the link opens named section in a new tab.
            </p>
        </div>

        <!--  -->
        <!--  -->
        <!--  -->
        <div class="popup-style" id="element04ToPopup">
            <div style="text-align: center;">
                <b>Page: The Algebra of Symbols</b></div>
            <p>
                The page is to introduce and describe an algebraic system, named "The
                Algebra of Symbols" or AoS. The AoS is developed as a solution of the Qualitative
                Dynamical Systems Mathematical Modeling Technique described on this page. It
                is intended to be used as the means of computation of functions of models of
                the qualitative systems implemented as the Extended Disjunctive Normal Form.
            </p>
            <p class="clickable-link">
                Clicking the link opens named page in a new tab.
            </p>
        </div>

        <!--  -->
        <!--  -->
        <!--  -->
        <div class="popup-style" id="element05ToPopup">
            <div style="text-align: center;">
                <b>Page: Extended Disjunctive Normal Form Expression Calculator</b></div>
            <p>
                This page illustrates mechanism of computation of several imaginary examples of state
                equation of a variable of model of qualitative dynamical system, written as y = f(args),
                where the functional (right-hand) part of the equation is defined in the form of the
                algebraic expression, structure of which is implemented as the Extended Disjunctive
                Normal Form.
            </p>
            <p class="clickable-link">
                Clicking the link opens named page in a new tab.
            </p>
        </div>

        <!--  -->
        <!--  -->
        <!--  -->
        <div class="popup-style" id="element06ToPopup">
            <div style="text-align: center;">
                <b>Page: Qualitative Systems</b></div>
            <p>
                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </p>
            <p class="clickable-link">
                Clicking the link opens named page in a new tab.
            </p>
        </div>

    </body>
</html>